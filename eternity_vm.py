import os
import time
import random

class EternityVM:
    def __init__(self):
        self.memory = bytearray()
        self.pc = 0 # Program Counter
        self.grid_size = 64
        self.grid = [[0 for _ in range(64)] for _ in range(64)]

    def load_program(self):
        if not os.path.exists("the_hidden_book.bin"):
            print("Error: Firmware not found.")
            return False
        with open("the_hidden_book.bin", "rb") as f:
            self.memory = bytearray(f.read())
        print(f"Firmware Loaded: {len(self.memory)} bytes")
        return True

    def run(self, cycles=1000):
        print("Booting Eternity VM...")
        print("Compiling Torah Bytecode into Cellular Automaton Rules...")
        
        # We treat the binary as a "seed" and a "rule modifier"
        # Seed the grid with the first N bytes
        idx = 0
        for r in range(self.grid_size):
            for c in range(self.grid_size):
                if idx < len(self.memory):
                    # Use byte parity to determine liveness
                    self.grid[r][c] = 1 if (self.memory[idx] % 2 != 0) else 0
                    idx += 1

        print("Simulation Started. (Press Ctrl+C to stop)")
        try:
            for i in range(cycles):
                self.update_grid(i)
                self.render()
                time.sleep(0.05)
        except KeyboardInterrupt:
            print("\nSimulation Halted.")

    def update_grid(self, cycle):
        # Conway's Game of Life logic, but "Torah-Modulated"
        # We assume the memory pointer advances and slightly mutates the rules
        # This simulates "Divine Intervention" or "External Input" from the code
        
        new_grid = [[0 for _ in range(self.grid_size)] for _ in range(self.grid_size)]
        
        # Mutation factor from the code
        mutation_byte = self.memory[cycle % len(self.memory)]
        
        for r in range(self.grid_size):
            for c in range(self.grid_size):
                live_neighbors = self.count_neighbors(r, c)
                
                # Standard Rules
                if self.grid[r][c] == 1:
                    if live_neighbors < 2 or live_neighbors > 3:
                        new_grid[r][c] = 0
                    else:
                        new_grid[r][c] = 1
                else:
                    if live_neighbors == 3:
                        new_grid[r][c] = 1
                        
                # The "Miracle" Rule:
                # If the mutation byte has a specific value, invert a cell
                # This tests if the code acts as an "active agent"
                if (r * c + cycle) % 255 == mutation_byte:
                    new_grid[r][c] = 1 - new_grid[r][c] # Flip state (Miracle)

        self.grid = new_grid

    def count_neighbors(self, r, c):
        count = 0
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0: continue
                nr, nc = r + i, c + j
                if 0 <= nr < self.grid_size and 0 <= nc < self.grid_size:
                    count += self.grid[nr][nc]
        return count

    def render(self):
        # Clear screen (hacky but works)
        # os.system('cls' if os.name == 'nt' else 'clear')
        # Just print top 10 lines to avoid spamming history too hard in some terminals
        # For full effect, we'd clear. Let's just print a "Frame" marker.
        
        buffer = []
        buffer.append("-" * (self.grid_size + 2))
        for r in range(self.grid_size // 2): # Render half height to fit
            line = "|"
            for c in range(self.grid_size):
                line += "â–ˆ" if self.grid[r][c] else " "
            line += "|"
            buffer.append(line)
        buffer.append("-" * (self.grid_size + 2))
        
        # Print frame over previous? 
        # In a basic terminal script log, animation is hard. 
        # We will just generate ONE snapshot of the "Life" generated by the code.
        pass

    def generate_snapshot(self):
        print("Generating System Snapshot at Cycle 0 (Genesis)...")
        self.load_program()
        # Seed
        idx = 0
        for r in range(self.grid_size):
            for c in range(self.grid_size):
                if idx < len(self.memory):
                    self.grid[r][c] = 1 if (self.memory[idx] % 2 != 0) else 0
                    idx += 1
        
        # Render to file or text
        with open("system_state.txt", "w", encoding="utf-8") as f:
            for row in self.grid:
                line = "".join(["#" if cell else "." for cell in row])
                f.write(line + "\n")
        print("System State Dumped to 'system_state.txt'.")
        print("This represents the 'Initial Conditions' defined by the Torah executable.")

if __name__ == "__main__":
    vm = EternityVM()
    vm.generate_snapshot()
